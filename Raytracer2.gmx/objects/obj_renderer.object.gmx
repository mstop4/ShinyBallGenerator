<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>100</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>randomize();

whee = 0;
drawit = 0;

render_surf = surface_create(render_width,render_height);

curX = 0;
curY = 0;
progress = 0;
max_progress = render_width * render_height;

xOffset = -5 * render_width/render_height;
yOffset = -5;

xStep = abs(xOffset*2)/render_width;
yStep = abs(yOffset*2)/render_height;

bg_r = 0.5;
bg_g = 0.5;
bg_b = 0.5;

light = instance_create(0,0,obj_light);
cam = instance_create(0,0,obj_camera);

numObj = 10;
for (var a=0; a&lt;numObj; a++)
{
    ball[a] = instance_create(0,0,obj_sphere);
}

/*light.lookAtX = -0.5;
light.lookAtY = -0.5;
light.lookAtZ = -1;

ball[0].posX = 2;
ball[0].posY = 0;
ball[0].posZ = 5;
ball[0].mat_diffuse_r = 1;
ball[0].mat_diffuse_g = 0;
ball[0].mat_diffuse_b = 0;
ball[0].radius = 3;

ball[1].radius = 1;
ball[1].posX = -1;
ball[1].posY = -3;
ball[1].posZ = 0;
ball[1].mat_diffuse_r = 0;
ball[1].mat_diffuse_g = 1;
ball[1].mat_diffuse_b = 0;

ball[2].radius = 2;
ball[2].posX = -4;
ball[2].posY = 0;
ball[2].posZ = 5;
ball[2].mat_diffuse_r = 0;
ball[2].mat_diffuse_g = 0.5;
ball[2].mat_diffuse_b = 1;*/

/*ball[3].radius = 2;
ball[3].posX = 4;
ball[3].posY = 0;
ball[3].posZ = 3;
ball[3].mat_diffuse_r = 0;
ball[3].mat_diffuse_g = 0;
ball[3].mat_diffuse_b = 1;

ball[4].radius = 2;
ball[4].posX = 0;
ball[4].posY = 4;
ball[4].posZ = 3;
ball[4].mat_diffuse_r = 0;
ball[4].mat_diffuse_g = 1;
ball[4].mat_diffuse_b = 1;*/

wt[0] = 0;
wt[1] = 90;
wt[2] = 180;
wt[3] = 270;
lt = 0;

fR = 0;
fG = 0;
fB = 0;
fdR = 0;
fdG = 0;
fdB = 0;
sR = 0;
sG = 0;
sB = 0;
pX = 0;
pY = 0;
pZ = 0;
nX = 0;
nY = 0;
nZ = 0;
rX = 0;
rY = 0;
rZ = 0;
ndl = 0;
ldn = 0;
vdr = 0;

rendering = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// real-time stuff
if (whee)
{
    //for (var i=0; i&lt;4; i++)
        wt[0] = (wt[0] + 1) mod 360;
        ball[0].posZ = dsin(wt[0]) * 5 + 5; 

    
    //light.lookAtX = -dcos(lt) * 1;
    //light.lookAtY = dsin(lt) * 1;
    //lt = (lt + 1) mod 360;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (rendering)
{
    for (a=0; a&lt;raysPerStep; a++)
    {
        var fR = 0;
        var fG = 0;
        var fB = 0;
        var fdR = 0;
        var fdG = 0;
        var fdB = 0;
        var sR = 0;
        var sG = 0;
        var sB = 0;
        var rR = 0;
        var rG = 0;
        var rB = 0;
        
        //compute ray
        var pewRayX = cam.lookAtX + (curX*xStep + xOffset) - cam.posX;
        var pewRayY = cam.lookAtY + (curY*yStep + yOffset) - cam.posY;
        var pewRayZ = cam.lookAtZ - cam.posZ;
        
        //normalize ray
        var vl = point_distance_3d(0,0,0,pewRayX,pewRayY,pewRayZ);
        
        pewRayX /= vl;
        pewRayY /= vl;
        pewRayZ /= vl;
        
        //cast ray and find intersection
        var t = 1000000;
        var target = -1;
        var ttemp = 0;
        
        for (var k=0; k&lt;numObj; k++)
        {       
            ttemp = raySphereIntersect(ball[k],(cam.posX-ball[k].posX),
                                            (cam.posY-ball[k].posY),
                                            (cam.posZ-ball[k].posZ),
                                            pewRayX,pewRayY,pewRayZ);
                                            
            if (ttemp &lt; t)
            {
                t = ttemp;
                target = k;
                fdR = ball[k].mat_diffuse_r;
                fdG = ball[k].mat_diffuse_g;
                fdB = ball[k].mat_diffuse_b;
            }
        }    
        
        // if hit
        if (t &lt; 1000000)
        {
            //ambient
            if (ambientOn)
            {
                fR = light.mat_ambient_r;
                fG = light.mat_ambient_g;
                fB = light.mat_ambient_b;
            }
            
            // find point of intersection
            var pX = cam.posX + pewRayX * t;
            var pY = cam.posY + pewRayY * t;
            var pZ = cam.posZ + pewRayZ * t;
            
            //find light
            var lRayDirX = light.lookAtX;
            var lRayDirY = light.lookAtY;
            var lRayDirZ = light.lookAtZ;
            
            vl = point_distance_3d(0,0,0,lRayDirX,lRayDirY,lRayDirZ);
            lRayDirX /= vl;
            lRayDirY /= vl;
            lRayDirZ /= vl;
                
            // find normal
            var nX = pX - ball[target].posX;
            var nY = pY - ball[target].posY;
            var nZ = pZ - ball[target].posZ;
            
            vl = point_distance_3d(0,0,0,nX,nY,nZ);
            nX /= vl;
            nY /= vl;
            nZ /= vl;
            
            // find reflected ray
            var ldn = dot_product_3d(lRayDirX,lRayDirY,lRayDirZ,nX,nY,nZ);
            
            var rX = lRayDirX - 2 * ldn * nX;
            var rY = lRayDirY - 2 * ldn * nY;
            var rZ = lRayDirZ - 2 * ldn * nZ;
            
            vl = point_distance_3d(0,0,0,rX,rY,rZ);
            rX /= vl;
            rY /= vl;
            rZ /= vl;
            
            var in_shadow = false;
            
            //find shadow
            if (shadowsOn)
            {
                for (var k=0; k&lt;numObj; k++)
                {
                    if (k == target)
                        continue;
                        
                    ttemp = raySphereIntersect(ball[k],pX-ball[k].posX,pY-ball[k].posY,pZ-ball[k].posZ,
                                                    lRayDirX,lRayDirY,lRayDirZ);
                    if (ttemp &lt; 1000000)
                    {
                        in_shadow = true;
                        break;
                    }
                }
            }
            
            if (!in_shadow)
            {
                if (diffuseOn)
                {    
                    // find diffuse
                    var ndl = dot_product_3d(nX,nY,nZ,lRayDirX,lRayDirY,lRayDirZ);
                    
                    if (ndl &gt; 0)
                    {
                        fR += light.mat_diffuse_r * power(ndl,5);
                        fG += light.mat_diffuse_g * power(ndl,5);
                        fB += light.mat_diffuse_b * power(ndl,5);
                    }
                }
                
               if (specularOn)
               {       
                    //find specular
                    
                    var vdr = dot_product_3d(pewRayX,pewRayY,pewRayZ,rX,rY,rZ);
                    
                    if (vdr &gt; 0 &amp;&amp; t &lt; 1000000)
                    {
                        sR = light.mat_specular_r * power(vdr,25);
                        sG = light.mat_specular_g * power(vdr,25);
                        sB = light.mat_specular_b * power(vdr,25);
                    }
                }
            }
            
            // find reflection
            if (reflectionsOn)
            {
                // find reflected ray
                var vdn = dot_product_3d(pewRayX,pewRayY,pewRayZ,nX,nY,nZ);
                
                var vrX = pewRayX - 2 * vdn * nX;
                var vrY = pewRayY - 2 * vdn * nY;
                var vrZ = pewRayZ - 2 * vdn * nZ;
                
                vl = point_distance_3d(0,0,0,vrX,vrY,vrZ);
                vrX /= vl;
                vrY /= vl;
                vrZ /= vl;
            
                var ref_a = reflection(pX,pY,pZ,vrX,vrY,vrZ,target);
                rR = ref_a[0];
                rG = ref_a[1];
                rB = ref_a[2];
            }
            
            fR = min(255,(fR*fdR+rR+sR)*255);
            fG = min(255,(fG*fdG+rG+sG)*255);
            fB = min(255,(fB*fdB+rB+sB)*255);
        }
        
        else
        {
            fR = bg_r * 255;
            fG = bg_g * 255;
            fB = bg_b * 255;
        } 
        
        // draw to surface
        if (!surface_exists(render_surf))
        {
            render_surf = surface_create(render_width,render_height);
            cur_x = 0;
            cur_y = 0;
            break;
        }
        
        surface_set_target(render_surf);
            draw_point_colour(curX,curY,make_colour_rgb(fR,fG,fB));
        surface_reset_target();
        
        // increment pointer
        curX++;
        if (curX &gt;= render_width)
        {
            curY++;
            curX = 0;
        }
        
        if (curY &gt;= render_height)
        {
            if (whee)
            {
                curX = 0;
                curY = 0;
            }
            
            else
            {
                rendering = false;
            }
        }
        
        progress = curY * render_width + curX;
    }
}

else
{
    if (!surface_exists(render_surf))
    {
        render_surf = surface_create(render_width,render_height);
        cur_x = 0;
        cur_y = 0;
        rendering = true;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>surface_free(render_surf);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!whee)
{
    if (drawit &amp;&amp; surface_exists(render_surf))
        draw_surface(render_surf,(room_width-render_width)/2,(room_height-render_height)/2);
}

else
    draw_surface_ext(render_surf,0,64,4,4,0,c_white,1);
    
var percent = string_format((progress/max_progress) * 100,5,2)

draw_set_font(fnt_rendering);
draw_set_halign(fa_left);
draw_set_valign(fa_bottom);

if (!drawit)
{
    if (progress &lt; max_progress)
        draw_text_outlined_ext(8,room_height-8,"Rendering... " + percent + "%",1,1,0,c_white,$404040,2,1,8);
    else
        draw_text_outlined_ext(8,room_height-8,"Rendering Complete! Press Enter.",1,1,0,c_white,$404040,2,1,8);
}

else
{
    if (!surface_exists(render_surf))
       draw_text(8,8,"Video Memory Error. Attempting Re-render.");
} 
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="123">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*if (!rendering)
{
    var fn = get_save_filename_ext("PNG|*.png", "screen.png", working_directory, "Save");
    if (fn &lt;&gt; "")
        surface_save(render_surf,fn);
}*/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>802</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_snapshot</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>2</kind>
            <string>screen.png</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="27">
      <action>
        <libid>1</libid>
        <id>224</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_another_room</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>11</kind>
            <room>room_title</room>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
